# 1 CPU
# 1.1 CPU 的内部结构
 - 寄存器：暂存指令、数据等处理对象。
 - 控制器：负责把内存上的指令、数据等读入寄存器， 并根据指令的执行结果来控制整个计算机。
 - 运算器：负责运算从内存读 入寄存器的数据。
 - 时钟：负责发出 CPU 开始计时的时钟信号。
## 1.2 CPU 是寄存器的集合体
程序是把寄存器作为对象来描述的。  
```
mov eax, dword ptr [ebp-8]  ...把数值从内存复制到 eax
add eax, dword ptr [ebp-0Ch]  ...exa 的数值和内存的数值相加
mov dword ptr [ebp-4], eax ...把 exa 的数值
```
mov表示存储，add表示相加；eax，ebp都是寄存器。  

## 1.3 决定程序流程的程序计数器
程序开始时，会将程序计数器(CPU 寄存器的一种)设定为0100。CPU 每执行一个指令，程序计数器的值就会自动加1。  
CPU的控制器就会参照程序计数器的数值，从内存中读取命令并执行。也就是说，程序计数器决定着程序的流程。  

## 1.4 条件分支和循环机制
顺序执行是指按照地址内容的顺序执行指令。  
条件分支是指根据条件执行任意地址的指令。  
循环是指重复执行同一地址的指令。  

## 1.5 函数的调用机制
函数的调用需要在完成函数内部的处理后，处理流程再返回到函数调用点(函数调用指令的下一个地址)。

## 1.6 通过地址和索引实现数组
使用基址寄存器和变址寄存器可以对内存进行划分，实现类似数组的操作。
查看10000000地址~1000FFFF地址时，可以将10000000存入基址寄存器， 
并使变址寄存器的值在00000000~0000FFFF变化。CPU则会把基址寄存器+变址寄存器的值解释为实际查看的内存地址。
变址寄存器的值就相当于高级编程语言程序中数组的索引功能。  

# 2 二进制
## 2.1 用二进制数表示计算机信息的原因
CPU是一种集成电路（IC），IC的所有引脚，只有直流电压0V或5VB两个状态。也就是说，IC的一个引脚，只能表示两个状态。  
计算机处理信息的最小单位——位，就相当于二进制中的一位。8位二进制数被称为一个字节。  

## 2.2 什么是二进制数
pass

## 2.3 移位运算和乘除运算的关系
移位运算指的是将二进制数值的各数位进行左右移位(shift = 移位)的运算。  
移位有左移(向高位方向)和右移(向低位方向)两种。  
十进制数左移后会变 成原来的 10 倍、100 倍、1000 倍......
同样，二进制数左移后就会变成 原来的 2 倍、4 倍、8 倍......反之，二进制数右移后则会变成原来的 1/2、1/4、1/8  
这就是为什么移位运算能代替乘除运算的原因。

## 2.4 便于计算机处理的“补数”
二进制数中表示负数值时，一般会把最高位作为符号来使用，因此我们把这个最高位称为符号位。  
符号位是 0 时表示正数 ，符号位是 1 时表示负数。  
将一个正数转换成负数：  
就是将各数位的 0 取反成 1， 1 取反成 0，然后再将取反的结果加 1。  
例如 1 转换成 -1：  
00000001 -> 11111110 -> 11111111  
那么用 1 + (-1)： 
```text
    00000001  
+   11111111
   100000000   # 最高位溢出的1被忽略
```

## 2.5 逻辑右移和算术右移的区别
右移有移位后在最高位补 0 和补 1 两种情况。  
当二进制数的值表示图形模式而非数值时，移位后需要在最高位补0。类似于霓虹灯往右滚动的效果。这就称为逻辑右移。  
将二进制数作为带符号的数值进行运算时，移位后要在最高位填充移位前符号位的值(0 或 1)。这就称为算术右移。   
如果数值是用补数表示的负数值，那么右移后在空出来的最高位补1，就可以正确地实现 1/2、1/4、1/8 等的数值运算。  
如果是正数，只需在最高位补0即可。  
总结：  
 - 图形模式下，逻辑右移：最高位补0
 - 数值运算下，算术右移：正数最高位补0；负数最高位补1。

## 2.6 掌握逻辑运算的窍门
逻辑运算是指对二进制数各数字位的 0 和 1 分别进行处理的运算， 
包括逻辑非(NOT 运算)、逻辑与(AND 运 算)、逻辑或(OR 运算)和逻辑异或(XOR 运算 A)四种。  
 - 逻辑非指的是0变成1、1变成0的取反操作。
 - 逻辑与指的是“两个都是1”时，运算结果为1，其他情况下运算结果都为0的运算。
 - 逻辑或指的是“至少有一方是1”时，运算结果为1，其他情况下运算结果都是0的运算。
 - 逻辑异或指的是排斥相同数值的运算。“两个数值不同”，也就是说，当“其中一方是1，另一方是0”时运算结果是1，其他情况下结果都是0。  

# 3 计算机进行小数运算时出错的原因
##  3.1 将 0.1 累加 100 次也得不到 10
```python
a = 0
for i in range(100):
    a += 0.1
print(a)
```
```text
9.99999999999998
```
## 3.2 用二进制数表示小数
把 1011.0011 这个有小数点的二进制数转换成十进制数:
```text
1 0 1 1 . 0 0 1 1
2^3 + 0 + 2^1 + 2^0 + 0 + 0 + 2^(-3) + 2^(-4) = 11.1875
```
## 3.3 计算机运算出错的原因
有一些十进制数的小数无法转换成二进制数。例如，十进制数0.1，就无法用二进制数正确表示，小数点后面即使有几百位也无法表示。  
小数点后4位用二进制数表示时的数值范围为 0.0000~0.1111。
因此，这里只能表示 0.5、0.25、0.125、0.0625 这四个二进制数小数点后面的位权组合而成(相加总和)的小数。    
实际上，不管增加多少小数位，十进制数 0.1 转换成二进制后，会变成 0.00011001100...(1100 循环)这样的循环小数。这和无法用十进制数来表示 1/3 是一样的道理。  

## 3.4 什么是浮点数
浮点数是指用符号、尾数、基数和指数这四部分来表示的小数。
```text
(+-)m * n^e
(符号)尾数*基数^指数
```
因为计算机内部使用的是二进制数，所以基数自然就是2。因此，实际的数据中往往不考虑基数，只用符号、尾数、指数这三部分即可表示浮点数。  

## 3.5 正则表达式和 EXCESS 系统
尾数部分使用正则表达式，可以将表现形式多样的浮点数统一为一种表现形式。  
例如，十进制数 0.75 就有很多种表现形式:
```text
0.75*10^(0)
0.75*10^(-2)
```
因此，为了方便计算机处理，需要制定一个统一的规则。  
在二进制数中，我们使用的是“ 将小数点前面的值固定为 1 的正则表达式”。  
具体来讲，就是将二进制数表示的小数左移或右移(这里是逻辑移位。因为符号位是独立的)数次后，整数部分的第 1 位变为 1，
第 2 位之后都变为 0(这样是为了消除第 2 位以上的数位)。而且，第 1 位的 1 在实际的数据中不保存。  

## 3.8 二进制数和十六进制数
二进制数的 4 位，正好相当于十六进制数的 1 位。
例如，32 位二进制数 0011 1101 1100 1100 1100 1100 1100 1101 用十六进制数来表示的话，就是 3DCCCCCD 这个 8 位数。

# 4 内存
## 4.1 内存的物理机制很简单
内存实际上是一种名为内存 IC 的电子元件。  
## 4.2 内存的逻辑模型是楼房
虽然内存的实体是内存 IC，不过从程序员的角度来看，也可以把它假想成每层都存储着数据的楼房，在这个楼房中，1层可以存储1个字节的数据，楼层号表示的就是地址。  
变量的数据类型不同，所占用的内存大小也不一样。如long类型占用4个字节，那么就占据4层。  
## 4.3 简单的指针
C语言中，在定义指针时，我们通常会在变量名前加一个星号(*)
```
char *d;
short *e;
long *f;
```
因为要存储变量长度，所以在变量名前加上了数据类型，这样在使用指针访问内存时，就能知道要访问几个字节。  

## 4.4 数组是高效使用内存的基础
因为数组和内存的物理构造是一样的。特别是1字节类型（char 类型）的数组，它和内存的物理构造完全一致。
