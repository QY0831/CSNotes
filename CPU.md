# 1 CPU
# 1.1 CPU 的内部结构
 - 寄存器：暂存指令、数据等处理对象。
 - 控制器：负责把内存上的指令、数据等读入寄存器， 并根据指令的执行结果来控制整个计算机。
 - 运算器：负责运算从内存读 入寄存器的数据。
 - 时钟：负责发出 CPU 开始计时的时钟信号。
## 1.2 CPU 是寄存器的集合体
程序是把寄存器作为对象来描述的。  
```
mov eax, dword ptr [ebp-8]  ...把数值从内存复制到 eax
add eax, dword ptr [ebp-0Ch]  ...exa 的数值和内存的数值相加
mov dword ptr [ebp-4], eax ...把 exa 的数值
```
mov表示存储，add表示相加；eax，ebp都是寄存器。  

## 1.3 决定程序流程的程序计数器
程序开始时，会将程序计数器(CPU 寄存器的一种)设定为0100。CPU 每执行一个指令，程序计数器的值就会自动加1。  
CPU的控制器就会参照程序计数器的数值，从内存中读取命令并执行。也就是说，程序计数器决定着程序的流程。  

## 1.4 条件分支和循环机制
顺序执行是指按照地址内容的顺序执行指令。  
条件分支是指根据条件执行任意地址的指令。  
循环是指重复执行同一地址的指令。  

## 1.5 函数的调用机制
函数的调用需要在完成函数内部的处理后，处理流程再返回到函数调用点(函数调用指令的下一个地址)。

## 1.6 通过地址和索引实现数组
使用基址寄存器和变址寄存器可以对内存进行划分，实现类似数组的操作。
查看10000000地址~1000FFFF地址时，可以将10000000存入基址寄存器， 
并使变址寄存器的值在00000000~0000FFFF变化。CPU则会把基址寄存器+变址寄存器的值解释为实际查看的内存地址。
变址寄存器的值就相当于高级编程语言程序中数组的索引功能。  

# 2 二进制
## 2.1 用二进制数表示计算机信息的原因
CPU是一种集成电路（IC），IC的所有引脚，只有直流电压0V或5VB两个状态。也就是说，IC的一个引脚，只能表示两个状态。  
计算机处理信息的最小单位——位，就相当于二进制中的一位。8位二进制数被称为一个字节。  

## 2.2 什么是二进制数
pass

## 2.3 移位运算和乘除运算的关系
移位运算指的是将二进制数值的各数位进行左右移位(shift = 移位)的运算。  
移位有左移(向高位方向)和右移(向低位方向)两种。  
十进制数左移后会变 成原来的 10 倍、100 倍、1000 倍......
同样，二进制数左移后就会变成 原来的 2 倍、4 倍、8 倍......反之，二进制数右移后则会变成原来的 1/2、1/4、1/8  
这就是为什么移位运算能代替乘除运算的原因。

## 2.4 便于计算机处理的“补数”
二进制数中表示负数值时，一般会把最高位作为符号来使用，因此我们把这个最高位称为符号位。  
符号位是 0 时表示正数 ，符号位是 1 时表示负数。  
将一个正数转换成负数：  
就是将各数位的 0 取反成 1， 1 取反成 0，然后再将取反的结果加 1。  
例如 1 转换成 -1：  
00000001 -> 11111110 -> 11111111  
那么用 1 + (-1)： 
```text
    00000001  
+   11111111
   100000000   # 最高位溢出的1被忽略
```

## 2.5 逻辑右移和算术右移的区别
右移有移位后在最高位补 0 和补 1 两种情况。  
当二进制数的值表示图形模式而非数值时，移位后需要在最高位补0。类似于霓虹灯往右滚动的效果。这就称为逻辑右移。  
将二进制数作为带符号的数值进行运算时，移位后要在最高位填充移位前符号位的值(0 或 1)。这就称为算术右移。   
如果数值是用补数表示的负数值，那么右移后在空出来的最高位补1，就可以正确地实现 1/2、1/4、1/8 等的数值运算。  
如果是正数，只需在最高位补0即可。  
总结：  
 - 图形模式下，逻辑右移：最高位补0
 - 数值运算下，算术右移：正数最高位补0；负数最高位补1。

## 2.6 掌握逻辑运算的窍门
逻辑运算是指对二进制数各数字位的 0 和 1 分别进行处理的运算， 
包括逻辑非(NOT 运算)、逻辑与(AND 运 算)、逻辑或(OR 运算)和逻辑异或(XOR 运算 A)四种。  
 - 逻辑非指的是0变成1、1变成0的取反操作。
 - 逻辑与指的是“两个都是1”时，运算结果为1，其他情况下运算结果都为0的运算。
 - 逻辑或指的是“至少有一方是1”时，运算结果为1，其他情况下运算结果都是0的运算。
 - 逻辑异或指的是排斥相同数值的运算。“两个数值不同”，也就是说，当“其中一方是1，另一方是0”时运算结果是1，其他情况下结果都是0。  

# 3 计算机进行小数运算时出错的原因
##  3.1 将 0.1 累加 100 次也得不到 10
```python
a = 0
for i in range(100):
    a += 0.1
print(a)
```
```text
9.99999999999998
```
## 3.2 用二进制数表示小数
把 1011.0011 这个有小数点的二进制数转换成十进制数:
```text
1 0 1 1 . 0 0 1 1
2^3 + 0 + 2^1 + 2^0 + 0 + 0 + 2^(-3) + 2^(-4) = 11.1875
```
## 3.3 计算机运算出错的原因
有一些十进制数的小数无法转换成二进制数。例如，十进制数0.1，就无法用二进制数正确表示，小数点后面即使有几百位也无法表示。  
小数点后4位用二进制数表示时的数值范围为 0.0000~0.1111。
因此，这里只能表示 0.5、0.25、0.125、0.0625 这四个二进制数小数点后面的位权组合而成(相加总和)的小数。    
实际上，不管增加多少小数位，十进制数 0.1 转换成二进制后，会变成 0.00011001100...(1100 循环)这样的循环小数。这和无法用十进制数来表示 1/3 是一样的道理。  

## 3.4 什么是浮点数
浮点数是指用符号、尾数、基数和指数这四部分来表示的小数。
```text
(+-)m * n^e
(符号)尾数*基数^指数
```
因为计算机内部使用的是二进制数，所以基数自然就是2。因此，实际的数据中往往不考虑基数，只用符号、尾数、指数这三部分即可表示浮点数。  

## 3.5 正则表达式和 EXCESS 系统
尾数部分使用正则表达式，可以将表现形式多样的浮点数统一为一种表现形式。  
例如，十进制数 0.75 就有很多种表现形式:
```text
0.75*10^(0)
0.75*10^(-2)
```
因此，为了方便计算机处理，需要制定一个统一的规则。  
在二进制数中，我们使用的是“ 将小数点前面的值固定为 1 的正则表达式”。  
具体来讲，就是将二进制数表示的小数左移或右移(这里是逻辑移位。因为符号位是独立的)数次后，整数部分的第 1 位变为 1，
第 2 位之后都变为 0(这样是为了消除第 2 位以上的数位)。而且，第 1 位的 1 在实际的数据中不保存。  

## 3.8 二进制数和十六进制数
二进制数的 4 位，正好相当于十六进制数的 1 位。
例如，32 位二进制数 0011 1101 1100 1100 1100 1100 1100 1101 用十六进制数来表示的话，就是 3DCCCCCD 这个 8 位数。

# 4 内存
## 4.1 内存的物理机制很简单
内存实际上是一种名为内存 IC 的电子元件。  
## 4.2 内存的逻辑模型是楼房
虽然内存的实体是内存 IC，不过从程序员的角度来看，也可以把它假想成每层都存储着数据的楼房，在这个楼房中，1层可以存储1个字节的数据，楼层号表示的就是地址。  
变量的数据类型不同，所占用的内存大小也不一样。如long类型占用4个字节，那么就占据4层。  
## 4.3 简单的指针
C语言中，在定义指针时，我们通常会在变量名前加一个星号(*)
```
char *d;
short *e;
long *f;
```
因为要存储变量长度，所以在变量名前加上了数据类型，这样在使用指针访问内存时，就能知道要访问几个字节。  

## 4.4 数组是高效使用内存的基础
数组和内存的物理构造是一样的。特别是1字节类型（char 类型）的数组，它和内存的物理构造完全一致。

## 4.5 栈、队列以及环形缓冲区
栈和队列，都可以不通过指定地址和索引来对数组的元素进行读写。
栈用的是 LIFO(Last Input First Out，后入先出)方式，而队列用的则是 FIFO(First Input First Out，先入先出)方式。  
如果我们在内存中预留出栈和队列所需要的空间，并确定好写入和读出的顺序，就不用再指定地址和索引了。  
队列一般是以环状缓冲区(ring buffer)的方式来实现的。  

## 4.6 链表使元素的追加和删除更容易
在数组的各个元素中，除了数据的值之外，通过为其附带上下一 个元素的索引，即可实现链表。  
通过使用链表，可以更加高效地对数组数据(元素)进行追加和删除处理。  

## 4.7 二叉查找树使数据搜索更有效
二叉查找树是指在链表的基础上往数组中追加元素时，考虑到数据的大小关系，将其分成左右两个方向的表现形式。  
二分查找的效率是logN。  

# 5 内存和磁盘的亲密关系
## 5.1 不读入内存就无法运行
计算机中主要的存储部件是内存和磁盘。磁盘中存储的程序，必须要加载到内存后才能运行。  
## 5.2 磁盘缓存加快了磁盘访问速度
磁盘缓存指的是把从磁盘中读出的数据存储到内存空间中的方式。这样一来，当接下来需要读取同一数据时，就不用通过实际的磁盘，而是从磁盘缓存中把内容读出。  
## 5.3 虚拟内存把磁盘作为部分内存来使用
虚拟内存是指把磁盘的一部分作为假想的内存来使用。这与磁盘缓存是假想的磁盘(实际上是内存)相对，虚拟内存是假想的内存(实际上是磁盘)。  
通过借助虚拟内存，在内存不足时也可以运行程序。
例如，在只剩下 5MB 内存空间的情况下也能运行 10MB 大小的程序。
不过，CPU只能执行加载到内存中的程序。
虚拟内 存虽说是把磁盘作为内存的一部分来使用，但实际上正在运行的程序部分，在这个时间点上是必须存在在内存中的。
也就是说，为了实现 虚拟内存，就必须把实际内存(也可称为物理内存)的内容，和磁盘上的虚拟内存的内容进行部分置换(swap)，并同时运行程序。  
## 5.4 节约内存的编程方法
许多人可能会认为，通过借助磁盘虚拟内存就可以解决内存不足的问题。而虚拟内存也确实能避免因内存不足导致的应用无法启动。  
为了从根本上解决内存不足的问题，需要增加内存的容量，或者尽量把运行的应用文件变小。  
通过 DLL 文件实现函数共有:   
DDL是在程序运行时可以动态加载 Library(函数和数据的集合)的文件, 多个应用可以共有同一个 DLL 文件以节省内存。
## 5.5 磁盘的物理结构
磁盘是通过把其物理表面划分成多个空间来使用的。  
划分的方式有扇区方式和可变长方式两种，前者是指将磁盘划分为固定长度的空间，后者则是指把磁盘划分为长度可变的空间。  
一般的 Windows 计算机所使用的硬盘和软盘，采用的都是扇区方式。扇区是对磁盘进行物理读写的最小单位。Windows中使用的磁盘，一般1个扇区是512字节。  
不过，Windows 在逻辑方面(软件方面)对磁盘进行读写的单位是扇区整数倍簇。
根据磁盘容量的不同，1 簇可以是 512 字节(1 簇 = 1 扇区)、1KB(1 簇 = 2 扇区)、2KB、4KB、8KB、16KB、32KB(1 簇 = 64 扇区)。磁盘的容量越大，簇的容量也越大。  
一个文件无论多小，至少占用1个簇。

# 6 压缩数据
## 6.1 文件以字节为单位保存
程序文件中存储数据的单位是字节。文件的大小之所以用 ××KB、××MB 等来表示，就是因为文件是以字节(B = Byte)为单位来存储的。
## 6.2 RLE 算法的机制
AAAAAABBCDDEEEEEF 就可以用 A6B2C1D2E5F1 来表示。  
把文件内容用“数据 × 重复次数”的形式来表示的压缩方法称为 RLE(Run Length Encoding，行程长度编码)算法。  
## 6.3 RLE 算法的缺点
然而，在实际的文本文件中，同样字符多次重复出现的情况并不多见。
虽然针对相同数据经常连续出现的图像、文件等，RLE 算法可以发挥不错的效果，但它并不适合文本文件的压缩。  
## 6.4 通过莫尔斯编码来看哈夫曼算法的基础
pass

# 7 程序是在何种环境中运行的
## 7.1 运行环境 = 操作系统 + 硬件
软件都会标注它需要都运行环境，包括操作系统和硬件两项。
## 7.2 Windows 克服了 CPU 以外的硬件差异
在 Windows 的应用软件中，键盘输入、显示器输出等并不是直接向硬件发送指令，而是通过向 Windows 发送指令来间接实现的。  
## 7.3 不同操作系统的 API 不同
应用程序向操作系统传递指令的途径称为 API(Application Programming Interface)
Windows 及 Unix 系列操作系统的 API，提供了任何应用程序都可以利用的函数组合。
因为不同操作系统的 API 是有差异的，因此，将同样的应用程序移植到其他操作系统时，就必须要重写应用中利用到 API 的部分。  
## 7.4 FreeBSD Port 帮你轻松使用源代码
pass
## 7.5 利用虚拟机获得其他操作系统环境
即使不通过移植，也可以使用别的方法来运行其他操作系统的应用: 利用虚拟机软件。
## 7.6 提供相同运行环境的 Java 虚拟机
同其他编程语言相同，Java 也是将 Java 语法记述的源代码编译后运行。
不过，编译后生成的并不是特定 CPU 使用的本地代码，而是名为字节代码的程序。
字节代码的运行环境就称为 Java 虚拟机(JavaVM，Java Virtual Machine)。Java 虚拟机是一边把 Java 字节代码逐一转换成本地代码一边运行的。
## 7.7 BIOS 和引导
程序的运行环境中，存在着名为 BIOS(Basic Input/Output System)的系统。
BIOS 存储在 ROM 中，是预先内置在计算机主机内部的程序。
BIOS除了键盘、磁盘、显卡等基本控制程序外，还有启动“引导程序”的功能。  
开机后，BIOS 会确认硬件是否正常运行，没有问题的话就会启动 引导程序。
引导程序的功能是把在硬盘等记录的 OS 加载到内存中运行。
虽然启动应用是 OS 的功能，但 OS 并不能自己启动自己，而是通过引导程序来启动。

# 8 从源文件到可执行文件
## 8.1 计算机只能运行本地代码
本地(native)这个术语有“母语的”意思。
对 CPU 来说，母语就是机器语言，而转换成机器语言的程序就是本地代码。用任何编程语言编写的源代码，最后都要翻译成本地代码(图 8-2)，否则 CPU 就不能理解。  
## 8.2 本地代码的内容
本地代码的内容是人类无法理解的，也正是因为如此，才有了用人类容易理解的 C 语言等编程语言来编写源代码，然后再将源代码转换成本地代码这一方法。
## 8.3 编译器负责转换源代码
能够把 C 语言等高级编程语言编写的源代码转换成本地代码的程序称为编译器。每个编写源代码的编程语言都需要其专用的编译器。
## 8.4 仅靠编译是无法得到可执行文件的
编译器转换源代码后，就会生成本地文件。不过，本地文件是无法直接运行的。为了得到可以运行的 EXE 文件，编译之后还需要进行“链接”处理。  
编译后生成的不是 EXE 文件，而是扩展名为“.obj”的 目标文件 A。 Sample1.c 编译后，就生成了 Sample1.obj 目标文件。  
在源代码中的调用的某些方法并没有记录在代码中，而是处于其他目标文件。  
把多个目标文件结合，生成 1 个 EXE 文件的处理就是链接，运行连接的程序就称为链接器(linkage editor 或连结器)。
## 8.5 启动及库文件
像 import32.lib 及 cw32.lib 这样的文件称为库文件。 
库文件指的是把多个目标文件集成保存到一个文件中的形式。
链接器指定库文件后，就会从中把需要的目标文件抽取出来，并同其他目标文件结合生成 EXE 文件。
## 8.6 DLL 文件及导入库
Windows 以函数的形式为应用提供了各种功能。这些形式的函数称为 API(Application Programming Interface，应用程序接口)。  
这些API的目标文件是存储在.lib文件里，.lib中存储着函数相关的ddl的信息。我们把类似于 import32.lib 这样的库文件称为导入库。
## 8.7 可执行文件运行时的必要条件
EXE 文件是作为单独的文件储存在硬盘中的。通过资源管理器找到并双击 EXE 文件，就会把 EXE 文件的内容加载到内存中运行。  
EXE 文件中给变量及函数分配了虚拟的内存地址。在程序运行时，虚拟的内存地址会转换成实际的内存地址。
## 8.8 程序加载时会生成栈和堆
当程序加载到内存后，除此之外还会额外生成两个组，那就是栈和堆。 
栈是用来存储函数内部临时使用的变量(局部变量)， 以及函数调用时所用的参数的内存区域。
堆是用来存储程序运行时的任意数据及对象的内存领域。  
栈中对数据进行存储和舍弃(清理处理)的代码，是由编译器自动生成的，因此不需要程序员的参与。  
使用栈的数据的内存空间，每当函数被调用时都会得到申请分配，并在函数处理完毕后自动释放。
与此相对，堆的内存空间，则要根据程序员编写的程序，来明确进行申请分配或释放。

## 编译器和解释器有什么不同?
编译器是在运行前对所有源代码进行解释处理的。而解释器则是在运行时对源代码的内容一行一行地进行解释处理的。
## “Build”指的是什么?
连续执行编译和链接。
## 使用 DLL 文件的好处是什么?
DLL 文件中的函数可以被多个程序共用。因此，借助该功能可以节约内存和磁盘。

# 9 操作系统和应用的关系
## 9.1 操作系统功能的历史
## 9.2 要意识到操作系统的存在
## 9.3 系统调用和高级编程语言的移植性
操作系统的硬件控制功能，通常是通过一些小的函数集合体的形式来提供的。
这些函数及调用函数的行为统称为系统调用(system call)，也就是应用对操作系统(system)的功能进行调用(call)的意思。  
## 9.4 操作系统和高级编程语言使硬件抽象化
通过使用操作系统提供的系统调用，程序员就没必要编写直接控制硬件的程序了。
而且，通过使用高级编程语言，有时甚至也无需考虑系统调用的存在。这是因为操作系统和高级编程语言能够使硬件抽象化。
比如，在程序中打开一个文件就是一次系统调用。

## 9.5 Windows 操作系统的特征
pass

# 10 通过汇编语言了解程序的实际构成












